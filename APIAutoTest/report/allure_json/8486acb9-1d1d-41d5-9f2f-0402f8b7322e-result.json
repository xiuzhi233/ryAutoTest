{"name": "验证【用户管理】下载模板，请求成功", "status": "broken", "statusDetails": {"message": "requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)", "trace": "self = <Response [200]>, kwargs = {}\n\n    def json(self, **kwargs):\n        r\"\"\"Returns the json-encoded content of a response, if any.\n    \n        :param \\*\\*kwargs: Optional arguments that ``json.loads`` takes.\n        :raises requests.exceptions.JSONDecodeError: If the response body does not\n            contain valid json.\n        \"\"\"\n    \n        if not self.encoding and self.content and len(self.content) > 3:\n            # No encoding set. JSON RFC 4627 section 3 states we should expect\n            # UTF-8, -16 or -32. Detect which one to use; If the detection or\n            # decoding fails, fall back to `self.text` (using charset_normalizer to make\n            # a best guess).\n            encoding = guess_json_utf(self.content)\n            if encoding is not None:\n                try:\n                    return complexjson.loads(self.content.decode(encoding), **kwargs)\n                except UnicodeDecodeError:\n                    # Wrong UTF codec detected; usually because it's not UTF-8\n                    # but some other 8-bit codec.  This is an RFC violation,\n                    # and the server didn't bother to tell us what codec *was*\n                    # used.\n                    pass\n                except JSONDecodeError as e:\n                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)\n    \n        try:\n>           return complexjson.loads(self.text, **kwargs)\n\n..\\.venv\\Lib\\site-packages\\requests\\models.py:971: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nX:\\Environments\\Python312\\Lib\\json\\__init__.py:346: in loads\n    return _default_decoder.decode(s)\nX:\\Environments\\Python312\\Lib\\json\\decoder.py:337: in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <json.decoder.JSONDecoder object at 0x000001ACD9A83B90>\ns = 'PK\\x03\\x04\\x14\\x00\\x08\\x08\\x08\\x00��xX\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x13\\x00\\x00\\x00[Content_Types]...\\x00\\x00\\x1a\\n\\x00\\x00xl/worksheets/sheet1.xmlPK\\x05\\x06\\x00\\x00\\x00\\x00\\t\\x00\\t\\x00?\\x02\\x00\\x00�\\x0c\\x00\\x00\\x00\\x00'\nidx = 0\n\n    def raw_decode(self, s, idx=0):\n        \"\"\"Decode a JSON document from ``s`` (a ``str`` beginning with\n        a JSON document) and return a 2-tuple of the Python\n        representation and the index in ``s`` where the document ended.\n    \n        This can be used to decode a JSON document from a string that may\n        have extraneous data at the end.\n    \n        \"\"\"\n        try:\n            obj, end = self.scan_once(s, idx)\n        except StopIteration as err:\n>           raise JSONDecodeError(\"Expecting value\", s, err.value) from None\nE           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\nX:\\Environments\\Python312\\Lib\\json\\decoder.py:355: JSONDecodeError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <APIAutoTest.test_case.test_ryvue.TestRyvue object at 0x000001ACDB52AAB0>, db_fixture = <APIAutoTest.common.db.DB object at 0x000001ACDAE698B0>\nrequest_fixture = <APIAutoTest.request_method.RequestMethod.RequestMethod object at 0x000001ACDB1A7E00>, case_number = 'userManagement_249', module_name = '系统管理'\napi_name = '用户管理', case_title = '验证【用户管理】下载模板，请求成功', request_url = 'http://192.168.109.134:81/prod-api/system/user/importTemplate', case_level = '高'\nrequest_method = 'POST', request_mime = 'application/x-www-form-urlencoded', request_data = None, request_expect = {'status_code': 200}, sql_type = None\nsql_sentence = None, update_key = None\n\n    @allure.epic(\"若依接口自动化测试\")\n    @log_decorator\n    @pytest.mark.parametrize(\n        \"case_number, module_name, api_name, case_title, case_level, request_url, request_method, request_mime, \"\n        \"request_data, request_expect, sql_type, sql_sentence, update_key\",\n        ReadExcel().get_data())\n    def test_ryvue(self, db_fixture, request_fixture, case_number, module_name, api_name, case_title, request_url,\n                   case_level, request_method, request_mime, request_data, request_expect, sql_type, sql_sentence,\n                   update_key):\n        # 调用allure功能，影响报告的显示\n        # @allure.feature(\"模块名称\")\n        allure.dynamic.feature(module_name)\n        # @allure.story(\"接口名称\")\n        allure.dynamic.story(api_name)\n        # @allure.title(\"用例标题\")\n        allure.dynamic.title(case_title)\n        # @allure.severity(\"用例等级\")\n        allure.dynamic.severity(case_level)\n        # 判断sql语句类型是否为DELETE\n        if sql_type == \"DELETE\":\n            # 使用DB类对象来执行删除的语句\n            db_fixture.delete(sql_sentence)\n    \n        elif sql_type == \"SELECT\":\n            # 使用DB类对象来执行查询的语句，接收查询的结果\n            select_result = db_fixture.select(sql_sentence)\n            # 将查询结果更新到用例数据中\n            request_data[update_key] = select_result\n            # 更新之后的用例数据发送给服务器\n    \n        elif sql_type == \"SELECT|DELETE\" or sql_type == \"DELETE|SELECT\":\n            # 使用DB类对象，调用delete方法执行删除语句；使用DB类对象来执行查询的语句，接收查询的结果\n            db_fixture.delete(sql_sentence.get(\"DELETE\"))\n            select_result = db_fixture.delete(sql_sentence.get(\"SELECT\"))\n            request_data[update_key] = select_result\n    \n        # 使用RequestMethod对象发送请求\n        response = request_fixture.request_all(req_method=request_method, req_url=request_url, req_mime=request_mime,\n                                               case_data=request_data)\n>       allure.dynamic.description(f\"actual_data:{response.json()}\")\n\ntest_case\\test_ryvue.py:59: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <Response [200]>, kwargs = {}\n\n    def json(self, **kwargs):\n        r\"\"\"Returns the json-encoded content of a response, if any.\n    \n        :param \\*\\*kwargs: Optional arguments that ``json.loads`` takes.\n        :raises requests.exceptions.JSONDecodeError: If the response body does not\n            contain valid json.\n        \"\"\"\n    \n        if not self.encoding and self.content and len(self.content) > 3:\n            # No encoding set. JSON RFC 4627 section 3 states we should expect\n            # UTF-8, -16 or -32. Detect which one to use; If the detection or\n            # decoding fails, fall back to `self.text` (using charset_normalizer to make\n            # a best guess).\n            encoding = guess_json_utf(self.content)\n            if encoding is not None:\n                try:\n                    return complexjson.loads(self.content.decode(encoding), **kwargs)\n                except UnicodeDecodeError:\n                    # Wrong UTF codec detected; usually because it's not UTF-8\n                    # but some other 8-bit codec.  This is an RFC violation,\n                    # and the server didn't bother to tell us what codec *was*\n                    # used.\n                    pass\n                except JSONDecodeError as e:\n                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)\n    \n        try:\n            return complexjson.loads(self.text, **kwargs)\n        except JSONDecodeError as e:\n            # Catch JSON-related errors and raise as requests.JSONDecodeError\n            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError\n>           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)\nE           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\n..\\.venv\\Lib\\site-packages\\requests\\models.py:975: JSONDecodeError"}, "attachments": [{"name": "log", "source": "9efc47e3-b842-472d-8b01-4a517f85f1dc-attachment.txt", "type": "text/plain"}], "parameters": [{"name": "case_number", "value": "'userManagement_249'"}, {"name": "module_name", "value": "'系统管理'"}, {"name": "api_name", "value": "'用户管理'"}, {"name": "case_title", "value": "'验证【用户管理】下载模板，请求成功'"}, {"name": "case_level", "value": "'高'"}, {"name": "request_url", "value": "'http://192.168.109.134:81/prod-api/system/user/importTemplate'"}, {"name": "request_method", "value": "'POST'"}, {"name": "request_mime", "value": "'application/x-www-form-urlencoded'"}, {"name": "request_data", "value": "None"}, {"name": "request_expect", "value": "{'status_code': 200}"}, {"name": "sql_type", "value": "None"}, {"name": "sql_sentence", "value": "None"}, {"name": "update_key", "value": "None"}], "start": 1711276144219, "stop": 1711276144247, "uuid": "1f4ea4a5-8ea8-428b-895e-86b98a704b15", "historyId": "a9b47f24cb4d75df94230cae06647421", "testCaseId": "71cd9252926fc3e5d5ed6b518138477a", "fullName": "test_case.test_ryvue.TestRyvue#test_ryvue", "labels": [{"name": "feature", "value": "系统管理"}, {"name": "story", "value": "用户管理"}, {"name": "severity", "value": "高"}, {"name": "epic", "value": "若依接口自动化测试"}, {"name": "parentSuite", "value": "test_case"}, {"name": "suite", "value": "test_ryvue"}, {"name": "subSuite", "value": "TestRyvue"}, {"name": "host", "value": "DESKTOP-P49BVBS"}, {"name": "thread", "value": "3236-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "test_case.test_ryvue"}]}